import{E as a,L as e,v as t,M as r}from"./server.mjs";function useAsyncData(...s){var n;const i="string"==typeof s[s.length-1]?s.pop():void 0;"string"!=typeof s[0]&&s.unshift(i);let[o,c,d={}]=s;if("string"!=typeof o)throw new TypeError("[nuxt] [asyncData] key must be a string.");if("function"!=typeof c)throw new TypeError("[nuxt] [asyncData] handler must be a function.");const l=a(),u=c;d.server??(d.server=!0),d.default??(d.default=()=>e.value),d.getCachedData??(d.getCachedData=()=>l.isHydrating?l.payload.data[o]:l.static.data[o]),d.lazy??(d.lazy=!1),d.immediate??(d.immediate=!0),d.deep??(d.deep=e.deep),d.dedupe??(d.dedupe="cancel");const y=d.getCachedData(o,l),f=null!=y;if(!l._asyncData[o]||!d.immediate){(n=l.payload._errors)[o]??(n[o]=e.errorValue);const a=d.deep?t.ref:t.shallowRef;l._asyncData[o]={data:a(f?y:d.default()),pending:t.ref(!f),error:t.toRef(l.payload._errors,o),status:t.ref("idle"),_default:d.default}}const p={...l._asyncData[o]};delete p._default,p.refresh=p.execute=(a={})=>{if(l._asyncDataPromises[o]){if("defer"===(s=a.dedupe??d.dedupe)||!1===s)return l._asyncDataPromises[o];l._asyncDataPromises[o].cancelled=!0}var s;if(a._initial||l.isHydrating&&!1!==a._initial){const e=a._initial?y:d.getCachedData(o,l);if(null!=e)return Promise.resolve(e)}p.pending.value=!0,p.status.value="pending";const n=new Promise(((a,e)=>{try{a(u(l))}catch(a){e(a)}})).then((async a=>{if(n.cancelled)return l._asyncDataPromises[o];let t=a;d.transform&&(t=await d.transform(a)),d.pick&&(t=function(a,e){const t={};for(const r of e)t[r]=a[r];return t}(t,d.pick)),l.payload.data[o]=t,p.data.value=t,p.error.value=e.errorValue,p.status.value="success"})).catch((a=>{if(n.cancelled)return l._asyncDataPromises[o];p.error.value=r(a),p.data.value=t.unref(d.default()),p.status.value="error"})).finally((()=>{n.cancelled||(p.pending.value=!1,delete l._asyncDataPromises[o])}));return l._asyncDataPromises[o]=n,l._asyncDataPromises[o]},p.clear=()=>function(a,t){t in a.payload.data&&(a.payload.data[t]=void 0);t in a.payload._errors&&(a.payload._errors[t]=e.errorValue);a._asyncData[t]&&(a._asyncData[t].data.value=void 0,a._asyncData[t].error.value=e.errorValue,a._asyncData[t].pending.value=!1,a._asyncData[t].status.value="idle");t in a._asyncDataPromises&&(a._asyncDataPromises[t]&&(a._asyncDataPromises[t].cancelled=!0),a._asyncDataPromises[t]=void 0)}(l,o);if(!1!==d.server&&l.payload.serverRendered&&d.immediate){const a=p.refresh({_initial:!0});t.getCurrentInstance()?t.onServerPrefetch((()=>a)):l.hook("app:created",(async()=>{await a}))}const m=Promise.resolve(l._asyncDataPromises[o]).then((()=>p));return Object.assign(m,p),m}export{useAsyncData as u};
//# sourceMappingURL=asyncData.mjs.map
